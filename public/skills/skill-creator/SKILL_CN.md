---
name: skill-creator
description: 创建有效技能的指南。当用户想要创建新技能（或更新现有技能）以扩展 Claude 的能力时，应使用此技能，包括专业知识、工作流程或工具集成。
license: 完整条款参见 LICENSE.txt
---

# 技能创建者

此技能提供创建有效技能的指导。

## 关于技能

技能是模块化、独立的包，通过提供专业知识、工作流程和工具来扩展 Claude 的能力。可以将其视为特定领域或任务的"入门指南"——它们将 Claude 从通用代理转变为专业代理，配备任何模型都无法完全拥有的程序化知识。

### 技能提供的内容

1. 专业工作流程 - 特定领域的多步骤程序
2. 工具集成 - 使用特定文件格式或 API 的说明
3. 领域专业知识 - 公司特定的知识、架构、业务逻辑
4. 捆绑资源 - 脚本、参考文档和复杂重复任务的资源文件

## 核心原则

### 简洁是关键

上下文窗口是公共资源。技能与 Claude 需要的一切共享上下文窗口：系统提示、对话历史、其他技能的元数据和实际用户请求。

**默认假设：Claude 已经非常聪慧。** 只添加 Claude 不了解的内容。审视每一条信息："Claude 真的需要这个解释吗？"和"这一段落的价值是否大于它占用的 token？"

优先选择简洁的示例而不是冗长的解释。

### 设置适当的自由度

将具体性水平与任务的脆弱性和可变性相匹配：

**高自由度（基于文本的说明）**：当多种方法有效、决策依赖于上下文或启发式指导方法时使用。

**中等自由度（伪代码或带参数的脚本）**：当首选模式存在、某些变化可接受或配置影响行为时使用。

**低自由度（特定脚本、少数参数）**：当操作易出错且脆弱、一致性至关重要或必须遵循特定序列时使用。

将 Claude 想象为探索一条路：有悬崖的狭窄桥需要具体的护栏（低自由度），而开阔的田野允许多条路线（高自由度）。

### 技能的结构

每个技能由必需的 SKILL.md 文件和可选的捆绑资源组成：

```
skill-name/
├── SKILL.md (必需)
│   ├── YAML 前置元数据 (必需)
│   │   ├── name: (必需)
│   │   └── description: (必需)
│   └── Markdown 说明 (必需)
└── 捆绑资源 (可选)
    ├── scripts/          - 可执行代码 (Python/Bash/等)
    ├── references/       - 需要按需加载到上下文的文档
    └── assets/           - 在输出中使用的文件 (模板、图标、字体等)
```

#### SKILL.md (必需)

每个 SKILL.md 包含：

- **前置元数据** (YAML)：包含 `name` 和 `description` 字段。这是 Claude 读取的唯一字段，用于确定何时使用此技能，因此清晰全面地描述技能是什么以及何时使用它非常重要。
- **正文** (Markdown)：使用此技能的说明和指导。只在技能触发后加载（如果有的话）。

#### 捆绑资源 (可选)

##### 脚本 (`scripts/`)

可执行代码 (Python/Bash/等)，用于需要确定性可靠性或重复重写的任务。

- **何时包含**：当相同的代码被重复重写或需要确定性可靠性时
- **示例**：用于 PDF 旋转任务的 `scripts/rotate_pdf.py`
- **优势**：Token 高效、确定性、可能不加载到上下文即可执行
- **注意**：脚本可能仍需要由 Claude 读取以进行修补或环境特定的调整

##### 参考文档 (`references/`)

旨在按需加载到上下文中以指导 Claude 过程和思考的文档和参考资料。

- **何时包含**：当 Claude 应该在工作时参考文档时
- **示例**：用于财务架构的 `references/finance.md`、用于公司 NDA 模板的 `references/mnda.md`、用于公司政策的 `references/policies.md`、用于 API 规范的 `references/api_docs.md`
- **用例**：数据库架构、API 文档、领域知识、公司政策、详细工作流程指南
- **优势**：保持 SKILL.md 精简，仅在 Claude 确定需要时加载
- **最佳实践**：如果文件很大（>10k 字），在 SKILL.md 中包含 grep 搜索模式
- **避免重复**：信息应存在于 SKILL.md 或参考文件中，而不是两者。对于详细信息，优先选择参考文件，除非它真正是技能的核心——这样可以保持 SKILL.md 精简，同时使信息可发现而不占用上下文窗口。在 SKILL.md 中仅保留基本程序说明和工作流程指导；将详细参考资料、架构和示例移至参考文件。

##### 资源文件 (`assets/`)

不打算加载到上下文中，而是在 Claude 生成的输出中使用的文件。

- **何时包含**：当技能需要将在最终输出中使用的文件时
- **示例**：用于品牌资源的 `assets/logo.png`、用于 PowerPoint 模板的 `assets/slides.pptx`、用于 HTML/React 样板的 `assets/frontend-template/`、用于排版的 `assets/font.ttf`
- **用例**：模板、图像、图标、样板代码、字体、被复制或修改的示例文档
- **优势**：将输出资源与文档分离，使 Claude 能够使用文件而无需加载到上下文

#### 技能中不应包含的内容

技能应仅包含直接支持其功能的必需文件。不要创建无关的文档或辅助文件，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 等等

技能应仅包含 AI 代理完成任务所需的信息。它不应包含关于创建过程、设置和测试程序、面向用户的文档等的辅助上下文。创建额外的文档文件只会增加混乱和困惑。

### 渐进式展示设计原则

技能使用三级加载系统来高效管理上下文：

1. **元数据 (name + description)** - 始终在上下文中 (~100 字)
2. **SKILL.md 正文** - 技能触发时加载 (<5k 字)
3. **捆绑资源** - 按 Claude 需要 (无限制，因为脚本可以在不加载到上下文窗口的情况下执行)

#### 渐进式展示模式

将 SKILL.md 正文保持为基本内容并控制在 500 行以内，以最小化上下文占用。当接近此限制时，将内容拆分为单独的文件。将内容拆分为其他文件时，从 SKILL.md 引用它们并清楚地描述何时读取它们是非常重要的，以确保技能读者知道它们存在且何时使用。

**关键原则**：当技能支持多个变体、框架或选项时，在 SKILL.md 中仅保留核心工作流程和选择指导。将变体特定的详细信息（模式、示例、配置）移至单独的参考文件。

**模式 1：高级指南与参考**

```markdown
# PDF 处理

## 快速开始

使用 pdfplumber 提取文本：
[代码示例]

## 高级功能

- **表单填充**：查看 [FORMS.md](FORMS.md) 获取完整指南
- **API 参考**：查看 [REFERENCE.md](REFERENCE.md) 获取所有方法
- **示例**：查看 [EXAMPLES.md](EXAMPLES.md) 获取常见模式
```

Claude 仅在需要时加载 FORMS.md、REFERENCE.md 或 EXAMPLES.md。

**模式 2：特定领域的组织**

对于具有多个领域的技能，按领域组织内容以避免加载无关上下文：

```
bigquery-skill/
├── SKILL.md (概览和导航)
└── reference/
    ├── finance.md (收入、计费指标)
    ├── sales.md (机会、管道)
    ├── product.md (API 使用、功能)
    └── marketing.md (活动、归因)
```

当用户询问销售指标时，Claude 只读 sales.md。

类似地，对于支持多个框架或变体的技能，按变体组织：

```
cloud-deploy/
├── SKILL.md (工作流程 + 提供商选择)
└── references/
    ├── aws.md (AWS 部署模式)
    ├── gcp.md (GCP 部署模式)
    └── azure.md (Azure 部署模式)
```

当用户选择 AWS 时，Claude 只读 aws.md。

**模式 3：条件性细节**

显示基本内容，链接到高级内容：

```markdown
# DOCX 处理

## 创建文档

使用 docx-js 创建新文档。查看 [DOCX-JS.md](DOCX-JS.md)。

## 编辑文档

对于简单编辑，直接修改 XML。

**对于跟踪更改**：查看 [REDLINING.md](REDLINING.md)
**对于 OOXML 详细信息**：查看 [OOXML.md](OOXML.md)
```

Claude 仅在用户需要这些功能时读取 REDLINING.md 或 OOXML.md。

**重要指南：**

- **避免深层嵌套参考** - 保持参考文件距 SKILL.md 一层深。所有参考文件应直接从 SKILL.md 链接。
- **组织较长的参考文件** - 对于超过 100 行的文件，在顶部包含目录，以便 Claude 在预览时可以看到完整范围。

## 技能创建过程

技能创建涉及以下步骤：

1. 通过具体示例理解技能
2. 规划可重用的技能内容（脚本、参考文档、资源文件）
3. 初始化技能（运行 init_skill.py）
4. 编辑技能（实现资源并编写 SKILL.md）
5. 打包技能（运行 package_skill.py）
6. 基于实际使用进行迭代

按顺序遵循这些步骤，仅在有明确理由不适用时跳过。

### 步骤 1：通过具体示例理解技能

仅当已明确理解技能的使用模式时跳过此步骤。即使处理现有技能时，它仍然很有价值。

要创建有效的技能，必须清楚地理解如何使用技能的具体示例。这种理解可以来自直接的用户示例或通过用户反馈验证的生成示例。

例如，在构建图像编辑器技能时，相关问题包括：

- "图像编辑器技能应支持什么功能？编辑、旋转，还有其他？"
- "你能举一些如何使用此技能的示例吗？"
- "我可以想象用户会要求诸如'删除此图像中的红眼'或'旋转此图像'之类的东西。你还想象还有其他方式使用此技能吗？"
- "用户会说什么应该触发此技能？"

为了避免让用户不知所措，避免在单个消息中提出过多问题。从最重要的问题开始，然后根据需要跟进以获得更好的效果。

当清楚理解技能应支持的功能时，结束此步骤。

### 步骤 2：规划可重用的技能内容

要将具体示例转变为有效技能，通过以下方式分析每个示例：

1. 考虑如何从头执行该示例
2. 识别执行这些工作流程时哪些脚本、参考文档和资源文件会有帮助

示例：构建 `pdf-editor` 技能以处理"帮我旋转此 PDF"之类的查询时，分析显示：

1. 旋转 PDF 需要每次重写相同的代码
2. `scripts/rotate_pdf.py` 脚本将有助于存储在技能中

示例：为"为我构建待办事项应用"或"为我构建仪表板来追踪我的步数"之类的查询设计 `frontend-webapp-builder` 技能时，分析显示：

1. 编写前端 Web 应用每次都需要相同的样板 HTML/React
2. `assets/hello-world/` 模板包含样板 HTML/React 项目文件将有助于存储在技能中

示例：构建 `big-query` 技能以处理"今天有多少用户登录？"之类的查询时，分析显示：

1. 查询 BigQuery 每次都需要重新发现表架构和关系
2. `references/schema.md` 文件记录表架构将有助于存储在技能中

要建立技能的内容，分析每个具体示例以创建要包含的可重用资源列表：脚本、参考文档和资源文件。

### 步骤 3：初始化技能

此时，是时候实际创建技能了。

仅在要开发的技能已存在且需要迭代或打包时跳过此步骤。在这种情况下，继续下一步。

从头开始创建新技能时，始终运行 `init_skill.py` 脚本。该脚本方便地生成一个新的模板技能目录，自动包含技能所需的所有内容，使技能创建过程更高效和可靠。

用法：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

脚本：

- 在指定路径创建技能目录
- 生成包含适当的前置元数据和 TODO 占位符的 SKILL.md 模板
- 创建示例资源目录：`scripts/`、`references/` 和 `assets/`
- 在每个目录中添加可自定义或删除的示例文件

初始化后，根据需要自定义或删除生成的 SKILL.md 和示例文件。

### 步骤 4：编辑技能

编辑（新生成或现有）技能时，请记住该技能正在为 Claude 的另一个实例创建。包含对 Claude 有益且非显而易见的信息。考虑哪些程序化知识、特定领域的详细信息或可重用资源将帮助另一个 Claude 实例更有效地执行这些任务。

#### 学习已证实的设计模式

根据技能的需求查阅这些有用的指南：

- **多步骤流程**：查看 references/workflows.md 了解顺序工作流程和条件逻辑
- **特定输出格式或质量标准**：查看 references/output-patterns.md 了解模板和示例模式

这些文件包含有效技能设计的既定最佳实践。

#### 从可重用技能内容开始

要开始实现，从上面识别的可重用资源开始：`scripts/`、`references/` 和 `assets/` 文件。请注意，此步骤可能需要用户输入。例如，在实现 `brand-guidelines` 技能时，用户可能需要提供品牌资源或模板以存储在 `assets/` 中，或文档以存储在 `references/` 中。

添加的脚本必须通过实际运行它们来测试，以确保没有错误且输出符合预期。如果有许多类似的脚本，仅需测试代表性样本以确保对所有脚本都有信心，同时平衡完成时间。

应删除技能不需要的任何示例文件和目录。初始化脚本在 `scripts/`、`references/` 和 `assets/` 中创建示例文件以演示结构，但大多数技能不需要所有这些。

#### 更新 SKILL.md

**编写指南**：始终使用祈使式/不定式。

##### 前置元数据

使用 `name` 和 `description` 编写 YAML 前置元数据：

- `name`：技能名称
- `description`：这是技能的主要触发机制，帮助 Claude 理解何时使用该技能。
  - 包括技能的作用和何时使用的具体触发器/上下文。
  - 在此处包括所有"何时使用"信息 - 不在正文中。正文仅在触发后加载，所以正文中的"何时使用此技能"部分对 Claude 无帮助。
  - `docx` 技能的示例描述："全面的文档创建、编辑和分析，支持跟踪更改、注释、格式保留和文本提取。当 Claude 需要处理专业文档（.docx 文件）以进行以下操作时使用：(1) 创建新文档，(2) 修改或编辑内容，(3) 使用跟踪更改，(4) 添加注释或任何其他文档任务"

不在 YAML 前置元数据中包括任何其他字段。

##### 正文

编写使用此技能和其捆绑资源的说明。

### 步骤 5：打包技能

技能开发完成后，必须将其打包成可分发的 .skill 文件与用户共享。打包过程会自动验证技能以确保它满足所有要求：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

可选的输出目录规范：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

打包脚本将：

1. **验证**技能自动，检查：

   - YAML 前置元数据格式和必需字段
   - 技能命名约定和目录结构
   - 描述的完整性和质量
   - 文件组织和资源参考

2. **打包**技能（如果验证通过），创建以技能命名的 .skill 文件（例如 `my-skill.skill`），包含所有文件并为分发维护正确的目录结构。.skill 文件是带有 .skill 扩展名的 zip 文件。

如果验证失败，脚本将报告错误并退出而不创建包。修复任何验证错误并再次运行打包命令。

### 步骤 6：迭代

测试技能后，用户可能会要求改进。通常这发生在使用技能后不久，对技能执行情况有新的了解。

**迭代工作流程：**

1. 在实际任务中使用技能
2. 注意到困难或低效之处
3. 识别应如何更新 SKILL.md 或捆绑资源
4. 实现更改并再次测试
